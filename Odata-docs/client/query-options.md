---
title: "Basic Queries Options"
description: "This tutorial describes how to use basic query options on client side"

author: mumbi-o
ms.author: mowambug
ms.date: 7/1/2019
ms.topic: article
 
---
# Query options
**Applies To**: [!INCLUDE[appliesto-odataclient](../includes/appliesto-odataclient-v7.md)]

There are mainly 2 ways to add Query Options to a DataServiceQuery
1. Using AddQueryOption method.
2. Using strongly typed C# LINQ query methods.

## AddQueryOption Method
The following example shows how to use to the `AddQueryOption` method to create a [DataServiceQuery&lt;TElement&gt;](/dotnet/api/microsoft.odata.client.dataservicequery-1) class, which implements the [IQueryable&lt;T&gt;](/dotnet/api/system.linq.iqueryable-1)

```csharp
DataServiceQuery peopleQuery = dsc.People
    .AddQueryOption("$filter", "Gender eq Microsoft.OData.SampleService.Models.TripPin.PersonGender'Female'")
    .AddQueryOption("$skip", "3")
    .AddQueryOption("$orderby", "UserName desc");

foreach (Person person in peopleQuery)
{
    Console.WriteLine($"Username: {person.UserName} First Name: {person.FirstName} Gender: {person.Gender}");
}
```

In the case above, the URI that is generated by the OData client includes the requested entity set together with the added query options.

## LINQ Query Methods
In the example below, we are creating a Linq query expression that returns only females, ordered by `UserName`. We skip the first 3 results and also specify which columns should be returned.

```csharp
DefaultContainer dsc = new DefaultContainer(new Uri("https://services.odata.org/V4/(S(uvf1y321yx031rnxmcbqmlxw))/TripPinServiceRW/"));

var query = dsc.People.Where(p => p.Gender == PersonGender.Female)
    .OrderByDescending(p => p.UserName)
    .Skip(3)
    .Select(p => new { p.FirstName, p.LastName, p.UserName, p.Gender });

foreach(var person in query)
{
    Console.WriteLine($"Username: {person.UserName} First Name: {person.FirstName} Gender: {person.Gender}");
}
```

Since the [DataServiceQuery&lt;TElement&gt;](/dotnet/api/microsoft.odata.client.dataservicequery-1) class implements the [IQueryable&lt;T&gt;](/dotnet/api/system.linq.iqueryable-1) interface (System.Linq), the OData client library is able to translate Linq queries against entity sets into URIs executed against a data service resource.

The examples below demonstrate the kinds of LINQ queries that can be used to create various query options.

## $filter

For `GET https://host/service/People?$filter=FirstName eq 'Peter'`:

``` csharp
var people = context.People.Where(c => c.FirstName == "Peter");
```

For `GET https://host/service/People?$filter=endswith(FirstName, 'Peter')`:

``` csharp
var people = context.People.Where(c => c.FirstName.EndsWith("Peter"));
```

For `GET https://host/service/People?$filter=Trips/$count eq 2`:

``` csharp
var people = context.People.Where(c => c.Trips.Count == 2);
```

For `GET https://host/service/People?$filter=Trips/any(d:d/Budget gt 6000)`:

``` csharp
var people = context.People.Where(c => c.Trips.Any(d => d.Budget > 6000));
```

For `GET https://host/service/People?$filter=UserName in ('russellwhyte', 'scottketchum', 'ronaldmundy')`:

``` csharp
var userNames = new List<string> { "russellwhyte", "scottketchum", "ronaldmundy" };
var people = context.People.Where(p => userNames.Contains(p.UserName));
```


## $count

For `GET https://host/service/People/$count`:

``` csharp
var count = context.People.Count();
```

For `GET https://host/service/People?$count=true`:

We have two ways of making this request.
``` csharp
var people = context.People.IncludeCount();
```
``` csharp
var people = context.People.IncludeCount(true);
```

For `GET https://host/service/People?$count=false`:

``` csharp
var people = context.People.IncludeCount(false);
```

## $orderby

For `GET https://host/service/People?$orderby=FirstName`:

``` csharp
var people = context.People.OrderBy(c => c.FirstName);
```

For `GET https://host/service/People?$orderby=FirstName desc`:

``` csharp
var people = context.People.OrderByDescending(c => c.FirstName);
```

For `GET https://host/service/People?$orderby=Trips/$count`:

``` csharp
var people = context.People.OrderBy(c => c.Trips.Count);
```

## $skip

For `GET https://host/service/People?$skip=3`:

``` csharp
var people = context.People.Skip(3);
```

## $top

For `GET https://host/service/People?$top=3`:

``` csharp
var people = context.People.Take(3);
```

## $expand

For `GET https://host/service/People?$expand=Trips`:

``` csharp
var people = context.People.Expand(c => c.Trips);
```

## $select

For `GET https://host/service/People` Selects all columns by default

OR

For `GET https://host/service/People?$select=*` Same as above

``` csharp
var people = context.People;
```

For `GET https://host/service/People?$select=FirstName,LastName`:

``` csharp
var people = context.People.Select(c => new {c.FirstName, c.LastName});
```

## A simple combined query combined

For `GET https://host/service/People?$expand=Trips&$filter=FirstName eq 'Peter'&$orderby=Firstname asc&$skip=3&$top=3`

``` csharp
var people =
    context.People
        .Expand(c => c.Trips)
        .Where(c => c.FirstName == "Peter")
        .OrderBy(c => c.FirstName)
        .Skip(3)
        .Take(3);
```

The order of the query options matters.
